import { Client, Room } from "colyseus.js";
import { useGameStore } from "../store/gameStore";
import type { GameState } from "../engine/types";

export class MultiplayerClient {
    private client: Client;
    private room: Room | null = null;
    // For production, this should be configurable
    private endpoint = this.resolveEndpoint();
    private healthPath = "/health";

    constructor() {
        this.client = new Client(this.endpoint);
    }

    private resolveEndpoint(): string {
        const envEndpoint = import.meta.env.VITE_COLYSEUS_ENDPOINT;
        if (typeof envEndpoint === "string" && envEndpoint.length > 0) {
            return envEndpoint;
        }

        return "ws://localhost:2567";
    }

    private getHealthUrl(): string | null {
        try {
            const url = new URL(this.endpoint);
            if (url.protocol === "ws:") {
                url.protocol = "http:";
            } else if (url.protocol === "wss:") {
                url.protocol = "https:";
            }

            if (url.protocol !== "http:" && url.protocol !== "https:") {
                return null;
            }

            url.pathname = this.healthPath;
            url.search = "";
            url.hash = "";
            return url.toString();
        } catch {
            return null;
        }
    }

    public async warmup(options?: { timeoutMs?: number }): Promise<boolean> {
        const healthUrl = this.getHealthUrl();
        if (!healthUrl) return false;

        const timeoutMs = options?.timeoutMs ?? 8000;
        const controller = new AbortController();
        const timeoutId = window.setTimeout(() => controller.abort(), timeoutMs);

        try {
            const response = await fetch(healthUrl, {
                method: "GET",
                mode: "cors",
                cache: "no-store",
                signal: controller.signal
            });
            return response.ok;
        } catch {
            return false;
        } finally {
            window.clearTimeout(timeoutId);
        }
    }

    public isConnected(): boolean {
        return !!this.room;
    }

    private saveSession(room: Room) {
        localStorage.setItem("cinco_vidas_roomId", room.id);
        localStorage.setItem("cinco_vidas_sessionId", room.sessionId);
    }

    private clearSession() {
        localStorage.removeItem("cinco_vidas_roomId");
        localStorage.removeItem("cinco_vidas_sessionId");
    }

    public hasSavedSession(): boolean {
        return !!localStorage.getItem("cinco_vidas_roomId") && !!localStorage.getItem("cinco_vidas_sessionId");
    }

    public async reconnect(): Promise<string | null> {
        const roomId = localStorage.getItem("cinco_vidas_roomId");
        const sessionId = localStorage.getItem("cinco_vidas_sessionId");

        if (!roomId || !sessionId) return null;

        try {
            console.log("Attempting reconnection...", roomId, sessionId);
            this.room = await this.client.reconnect(roomId, sessionId);
            this.setupRoomListeners();
            return this.room.id;
        } catch (e) {
            console.error("Reconnection failed:", e);
            this.clearSession(); // Invalid session
            return null;
        }
    }

    public async createRoom(options?: any) {
        try {
            this.room = await this.client.create("cinco_vidas", options);
            this.saveSession(this.room);
            this.setupRoomListeners();
            return this.room.id;
        } catch (e) {
            console.error("Create Room error:", e);
            throw e;
        }
    }

    public async joinRoom(roomId: string, options?: any) {
        try {
            this.room = await this.client.joinById(roomId, options);
            this.saveSession(this.room);
            this.setupRoomListeners();
            return this.room.id;
        } catch (e) {
            console.error("Join Room error:", e);
            throw e;
        }
    }

    public async joinOrCreateRoom(roomName: string, options?: any) {
        try {
            this.room = await this.client.joinOrCreate(roomName, options);
            this.saveSession(this.room);
            this.setupRoomListeners();
            return this.room.id;
        } catch (e) {
            console.error("Join/Create error:", e);
            throw e;
        }
    }

    public async createPrivateRoom(options?: any) {
        // Creates a new room with random ID generated by server
        return this.createRoom(options);
    }

    public async joinPrivateRoom(roomId: string, options?: any) {
        // Joins existing room by ID
        return this.joinRoom(roomId, options);
    }

    public leave() {
        this.clearSession(); // Explicit leave clears session
        this.room?.leave(true); // Send 'consented' = true
        this.room = null;
    }

    public surrender() {
        if (this.room) {
            this.room.send('surrender');
        }
    }

    public send(type: string, message?: any) {
        if (this.room) {
            this.room.send(type, message);
        } else {
            console.warn("Cannot send message, not connected:", type);
        }
    }

    private setupRoomListeners() {
        if (!this.room) return;

        console.log("Joined/Reconnected room:", this.room.id, "Session:", this.room.sessionId);

        // Set my player ID in store
        useGameStore.getState().setMyPlayerId(this.room.sessionId);

        // Listen for state changes
        this.room.onStateChange((state: any) => {
            // Convert Schema to plain JSON object
            const json = state.toJSON();

            // Update the global store (UI follows store)
            // Note: Schema mapping must match GameState interface perfectly
            useGameStore.getState().setGameState(json as GameState);
        });

        this.room.onLeave((code) => {
            console.log("Left room", code);
            // If code is not normal closure (1000), maybe retry?
            // But logic above handles explicit reconnect calls.
        });
    }
}

export const multiplayer = new MultiplayerClient();
